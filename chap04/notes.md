## 第四章 更多的bash shell命令

### 4.1 监测程序

#### 4.1.1 探测进程

​	ps命令的全称是process status，即进程状态的意思，主要作用是列出系统中当前正在运行的进程信息。

​	当程序运行在系统上时，我们称之为进程（process）。想要监测这些京城，需要熟悉ps命令的用法，它能输出运行在系统上的所有程序的许多信息。

​	默认情况下，ps命令并不会提供那么多的信息：

```shell
ps
#     PID TTY          TIME CMD
#  37494 pts/1    00:00:25 zsh
# 117527 pts/1    00:00:00 ps
```

​	默认情况下，ps命令指回显示运行在当前控制台下的属于当前用户的进程。在此例中，我们只运行了z shell（注意，shell也知识运行在系统上的另一个程序而已）以及ps命令本身。

​	上例中的基本输出显示了程序的进程ID（Process ID，PID）、它们运行在哪个终端（TTY）以及进程已用的CPU时间。

​	Linux系统中使用的GNU ps命令支持3中不同类型的命令行参数：

​	（1）Uninx风格的参数，前面加单破折线；

​	（2）BSD风格的参数，前面不加破折线；

​	（3）GNU风格的长参数，前面加双破折线。

​	具体使用发生查看man手册。

**1. Unix风格的参数**

​	-e参数指定显示所有运行在系统上的进程；-f参数则扩展了输出。

```shell
ps -ef
# UID          PID    PPID  C STIME TTY          TIME CMD
#kato       37494   37486  0 13:05 pts/1    00:00:25 /bin/zsh
#kato      122218   37494  0 21:57 pts/1    00:00:00 ps -f
```

​	UID：启动这些进程的用户；

​	PID：进程的进程ID；

​	PPID：父进程的进程号；

​	C：进程生命周期中的CPU利用率；

​	STIME：进程启动时的系统时间；

​	TTY：进程启动时的终端设备；

​	TIME：运行进程需要的累计CPU时间；

​	CMD：启动的程序名称。

​	如果想要更多的信息，可采用-l参数，它会产生一个长格式输出。

```shell
ps -l
#F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
#0 S  1000   37494   37486  0  80   0 -  5680 -      pts/1    00:00:25 zsh
#4 R  1000  123500   37494  0  80   0 -  3184 -      pts/1    00:00:00 ps
```

​	F：内核分配给进程的系统标记；

​	S：进程的状态（O：正在运行；S：在休眠；R：可运行，正等待运行；Z：僵化，进程已结束但父进程已不存在；T：停止）；

​	PRI：进程的优先级（数越大优先级越低）；

​	NI：谦让度值用来参与决定优先级；

​	ADDR：进程的内存地址；

​	SZ：假如进程被换出，所需交换空间的大致大小；

​	WCHAN：进程休眠的内核函数的地址。

**2. BSD风格的参数**

​	略。

**3. GNU长参数**

​	略。

### 4.1.2 实时监测进程

​	ps命令虽然在收集运行在系统上的进程信息时非常有用，但它只能显示某个时间点的信息。top命令跟ps命令相似，能够显示进程信息，但它是实时显示的。

​	top命令运行时，输出的第一部分显示的是系统的概况：第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。

​	平均负载有3个值：最近1分钟的、最近5分钟的和最近15分钟的平均负载。值越大说明系统的负载越高。由于进程短期的突发性活动，出现最近一分钟的高负载值也很常见，但如果近15分钟内的平均负载都很高，就说明系统可能有问题。

​	第二行显示了进程概要信息——top命令的输出中将进程叫作任务（task）：有多少进程处在运行、休眠、停止或是僵化状态。

​	下一行显示了CPU的概要信息。top根据进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将CPU利用率分成几类输出。

​	紧跟其后的两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存，当前永乐多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。

![top命令运行时的输出.png](https://github.com/katoluo/LinuxCommandLineAndShellScriptingBible/raw/master/chap04/images/top%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E8%BE%93%E5%87%BA.png)

​	最后一部分显示了当前运行中的进程的详细列表，有些列跟ps命令的输出类似。

​	PID：进程的ID；

​	USER：进程属主的名字；

​	PR：进程的优先级；

​	NI：进程的谦让度值；

​	VIRT：进程占用的虚拟内存总量；

​	RES：进程占用的物理内存总量；

​	SHR：进程和其他进程共享的内存总量；

​	S：进程的状态；

​	%CPU：进程使用的CPU时间比例；

​	%MEN：进程使用的内存占可用内存的比例；

​	TIME+：自进程启动到目前为止的CPU时间总量；

​	COMMAND：进程所对应的命令行名称，也就是启动的程序名。

### 4.1.3 结束进程

​	作为系统管理员，很重要的一个技能就是知道何时以及如何结束一个进程。

​	在Linux中，进程之间通过信号来通信。进程的信号就是预定义号的一个消息，进程能识别它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。大多数编写完善的程序都能接受和处理标准Unix进程信号。如下：

| 信号 | 名称 |             描述             |
| :--: | :--: | :--------------------------: |
|  1   | HUP  |             挂起             |
|  2   | INT  |             中断             |
|  3   | QUIT |           结束运行           |
|  9   | KILL |          无条件终止          |
|  11  | SEGV |            段错误            |
|  15  | TERM |          尽可能终止          |
|  17  | STOP |   无条件停止运行，但不终止   |
|  18  | TSTP | 停止或暂停，但继续在后台运行 |
|  19  | CONT |   在STOP或TSTP之后恢复执行   |

​	在Linux上有两个命令可以向运行中的进程发生进程信号。

**1. kill命令**

​	kill命令可通过进程ID（PID）给进程发信号。默认情况下，kill命令会向命令行中列出的全部PID发送一个TERM信号。遗憾的是，你只能用进程的PID而不能用命令名，所以kill命令有时并不好用。

​	要发送进程信号，你必须是进程的属主或登录为root用户。

```shell
kill 3940
# -bash: kill: (3940) - Operation not permitted
```

​	TERM信号告诉进程可能的话就停止运行。不过，如果有不服管教的进程，那它通常会忽略这个请求。如果要强制终止，-s参数支持指定其他信号（用信号名或信号值）。

​	下例中kill命令不会有任何输出。

```shell
kill -s HUP 3940

```

​		要检查kill命令是否有效，可再运行ps或top命令，看看问题进程是否已经停止。

**2. killall命令**

​	killall命令非常强大，它支持通过进程名而不是PID来结束进程。killall命令也支持通配符，这在系统因负载过大而变得很慢时很有用。

```shell
killall http*

```

​	上例中的命令结束了所有以http开头的进程，比如Apache Web服务器的httpd服务。

### 4.2 监测磁盘空间

​	系统管理员的另一个重要任务就是监测系统磁盘的使用情况。不管运行的是简单的Linux台式机还是大型的Linux服务器，你都要知道还有多少空间可留给你的应用程序。

#### 4.2.1 挂载存储媒体

​	如第三章中讨论的,Linux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为挂载（mounting）。

​	在今天的图形化桌面环境里,大多数Linux发行版都能自动挂载特定类型的可移动存储媒体。可移动存储媒体指的是可从PC上轻易移除的媒体,比如CD-ROM、软盘和U盘。

**1. mount 命令**

​	Linux上用来挂载媒体的命令叫作 mount 。默认情况下, mount 命令会输出当前系统上挂载的设备列表。

```shell
mount
# /dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)
# proc on /proc type proc (rw)
# sysfs on /sys type sysfs (rw)
# devpts on /dev/pts type devpts (rw,gid=5,mode=620)
# /dev/sda1 on /boot type ext3 (rw)
# tmpfs on /dev/shm type tmpfs (rw)
# ...
# /dev/sdb1 on /media/disk type vfat (rw,nosuid,nodev,uhelper=hal,shortname=lower,uid=503)
```

​	mount命令提供如下四部分信息：

​	（1）媒体的设备文件名

​	（2）媒体挂载到虚拟目录的挂载点

​	（3）文件系统类型

​	（4）已挂载媒体的访问状态

​	上面例子的最后一行输出中，U盘被GNOME桌面自动挂载到了挂载点/media/disk。vfat文件系统类型说明它是在Windows机器上被格式化的。

​	要手动在虚拟目录中挂载设备，需要以root用户身份登录，或是以root用户身份运行sudo命令。下面是手动挂载媒体设备的基本命令：

```shell
mount -t type device directory
```

​	type参数指定了磁盘被格式化的文件系统类型。Linux可以识别非常多的文件系统类型。如果是和Windows PC共用这些存储设备，通常得使用下列文件系统类型。

​	（1）vfat：Windows长文件系统。

​	（2）ntfs：Windows NT、XP、Vista以及Windows 7中广泛使用的高级文件系统。

​	（3）iso9660：标准CD-ROM文件系统。

​	大多数U盘和软盘会被格式化成vfat文件系统。而数据CD则必须使用iso9660文件系统类型。

​	后面两个参数定义了该存储设备的设备文件的位置以及挂载点在虚拟目录中的位置。比如说，手动将U盘/sda/sdb1挂载到/media/disk，可用下面的命令：

```shell
mount -t vfat /sda/sdb1 /media/disk
```

​	媒体设备挂载到了虚拟目录后，root用户就有了对该设备的所有访问权限，而其他用户的访问则会被限制。你可以通过目录权限（将在第七章中介绍）指定用户对设备的访问权限。

​	如果要用到mount命令的一些高级功能，查看man手册。

**2. umount命令**

​	从Linux系统上溢出一个可移动设备时，不能直接从系统上移除，而应该先卸载。

***

**窍门**	Linux上不能直接弹出已挂载的CD。如果你在从光驱中移除CD时遇到麻烦，通常是因为该CD还挂载在虚拟目录里。先卸载它，然后再去尝试弹出。

***

​	卸载设备的命令是umount。umount命令改得格式非常简单：

```shell
umount [directory | device]
```

​	umount命令支持通过设备文件或者是挂载点来指定要卸载的设备。如果有任何程序正在使用设备上的文件，系统就不会允许你卸载它：

```shell
[root@testbox mnt]# umount /home/rich/mnt
umount: /home/rich/mnt: device is busy
umount: /home/rich/mnt: device is busy
[root@testbox mnt]# cd /home/rich
[root@testbox rich]# umount /home/rich/mnt
[root@testbox rich]# ls -l mnt
total 0
[root@testbox rich]#
```

​	上例中，命令行提示符仍然在挂载设备的文件系统目录中，所以umount命令无法卸载该镜像文件。一旦命令提示符移出该镜像文件的文件系统，umount命令就能卸载该镜像文件。

#### 4.2.2 使用 df 命令

​	df命令的全称是Disk Free，显而易见它是统计磁盘中空闲的空间，也即空闲的磁盘块数。

​	有时你需要知道在某个设备上还有多少磁盘空间。df命令可以让你很方便地查看所有已挂载磁盘的使用情况。

```shell
$ df
Filesystem		1K-blocks	Used	Available	Use%	Mounted on
/dev/sda2		18251068	7703964	9605024		45%		/
/dev/sda1		101086		18680	77187		20%		/boot
tmpfs			119536		0		119536		0%		/dev/shm
/dev/sdb1		127462		113892	13570		90%		/media/disk
$
```

​	df命令显示每个有数据的已挂载文件系统。如你在前例中看到的，有些已挂载设备仅权限系统内部使用。命令输出如下：

​	（1）设备的设备文件位置；

​	（2）能容纳多少个1024字节大小的块

​	（3）已用了多少个1024字节大小的块

​	（4）还有多少个1024字节大小的块可用

​	（5）已用空间所占的比例；

​	（6）设备挂载到了哪个挂载点上。

​	df命令有一些命令行参数可用，详细请查看man手册。

#### 4.2.3 使用du命令

​	du命令的全称是Disk Used，统计磁盘有已经使用的空间。

​	通过 df 命令很容易发现哪个磁盘的存储空间快没了。系统管理员面临的下一个问题是,发生这种情况时要怎么办。

​	另一个有用的命令是 du 命令。 du 命令可以显示某个特定目录(默认情况下是当前目录)的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。

​	默认情况下, du 命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况,它会以磁盘块为单位来表明每个文件或目录占用了多大存储空间。对标准大小的目录来说,这个输出会是一个比较长的列表。

```shell
$ du
484		./.gstreamer-0.10
8		./Templates
```

​	每行输出左边的数值是每个文件或目录占用的磁盘块数。注意,这个列表是从目录层级的最底部开始,然后按文件、子目录、目录逐级向上。

​	这么用 du 命令(不加参数,用默认参数)作用并不大。我们更想知道每个文件和目录占用了多大的磁盘空间,但如果还得逐页查找的话就没什么意义了。

​	下面是能让 du 命令用起来更方便的几个命令行参数。

​	-c ：显示所有已列出文件总的大小

​	-h ：按用户易读的格式输出大小,即用K替代千字节,用M替代兆字节,用G替代吉字节。

​	-s ：显示每个输出参数的总计。

### 4.3 处理数据文件

​	当你有大量数据时,通常很难处理这些信息及提取有用信息。正如在上节中学习的 du 命令，系统命令很容易输出过量的信息。

​	Linux系统提供了一些命令行工具来处理大量数据。本节将会介绍一些每个系统管理员以及日常Linux用户都应该知道的基本命令,这些命令能够让生活变得更加轻松。

#### 4.3.1 排序数据

​	处理大量数据时的一个常用命令是sort命令。顾名思义，sort命令是对数据进行排序的。默认情况下，sort命令按照会话指定的默认语言的排序规则对文本文件中的数据行排序。

​	sort命令的命令行参数详细查看man手册。

​	-k 和 -t 参数在对按字段分隔的数据进行排序时非常有用，例如/etc/passwd文件。可以用 -t参数来指定字段分隔符，然后用 -k 参数来指定排序的字段。举个例子，要对前面提到的密码文件/etc/passwd根据用户ID进行数值排序,可以这么做：

```shell
$ sort -t ':' -k 3 -n /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
...
```

​	-n 参数在排序数值时非常有用,比如 du 命令的输出。

```shell
$ du -sh * | sort -nr
660K	bookcover.png
180K	chap04
124K	chap03
4.0K	README.md
4.0K	file
```

​	注意， -r 参数将结果按降序输出，这样就更容易看到目录下的哪些文件占用空间最多。

#### 4.3.2 搜索数据

​	Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。

​	你会经常需要在大文件中找一行数据,而这行数据又埋藏在文件的中间。这时并不需要手动翻看整个文件，用 grep 命令来帮助查找就行了。 grep 命令的命令行格式如下。

```shell
grep [options] pattern [file]
```

​	grep命令会在输入或指定的文件中查找包含匹配指定模式的字符串的行。grep的输出就是包含了匹配模式的行。

```shell
$ grep three file1
three
$ grep t file1
two
three
$
```

​	第一个例子在文件 file1 中搜索能匹配模式 three 的文本。 grep 命令输出了匹配了该模式的行。第二个例子在文件 file1 中搜索能匹配模式 t 的文本。这个例子里, file1 中有两行匹配了指定的模式,两行都输出了。

​	grep命令的命令行参数的详细使用查看man手册。

​	默认情况下, grep 命令用基本的Unix风格正则表达式来匹配模式。Unix风格正则表达式采用特殊字符来定义怎样查找匹配的模式。要想进一步了解正则表达式的细节,可以参考第20章的内容。

​	以下是在 grep 搜索中使用正则表达式的简单例子。

```shell
$ grep [tf] file1
two
three
four
five
$
```

​	正则表达式中的方括号表明 grep 应该搜索包含 t 或者 f 字符的匹配。如果不用正则表达式，grep 就会搜索匹配字符串 tf 的文本。

​	egrep 命令是 grep 的一个衍生，支持POSIX扩展正则表达式。POSIX扩展正则表达式含有更多的可以用来指定匹配模式的字符(参见第20章)。 fgrep 则是另外一个版本,支持将匹配模式指定为用换行符分隔的一列固定长度的字符串。这样就可以把这列字符串放到一个文件中，然后在 fgrep 命令中用其在一个大型文件中搜索字符串了。

#### 4.3.3 压缩数据

​	gzip 是Linux上最流行的压缩工具。gzip软件包是GNU项目的产物，意在编写一个能够替代原先Unix中 compress 工具的免费版本。详细的命令行参数查看man手册，这个软件包含有下面的工具。

​	（1）gzip ：用来压缩文件。

​	（2）zcat ：用来查看压缩过的文本文件的内容。

​	（3）gunzip ：用来解压文件。

#### 4.3.4 归档数据

​	tape archive 磁盘归档

​	虽然 zip 命令能够很好地将数据压缩和归档进单个文件,但它不是Unix和Linux中的标准归档工具。目前,Unix和Linux上最广泛使用的归档工具是 tar 命令。

​	tar 命令最开始是用来将文件写到磁带设备上归档的,然而它也能把输出写到文件里,这种用法在Linux上已经普遍用来归档数据了。

​	下面是 tar 命令的格式:

```shell
tar <操作参数> [选项]
```

​	tar是一个用于储存或提取tar文件的程序。 tar文件可放在磁盘中， 也可以存为普通文件。tar 的第一个参数必须是操作参数A、c、d、r、t、u、x  中的一个， 参数后面可跟着任意可选选项。 tar的最后一个参数是你要处理的文件或目录的名字。 如果你指定了一个目录， 该目录的所有子目录都将被加入存档。具体的用法查看man手册进行了解。